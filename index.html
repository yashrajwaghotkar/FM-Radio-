<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dev>Yash FM</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1e3c72">

    <style>
        /* Reset & Global Styles */
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body {
            width: 100%; height: 100%; overflow: hidden; position: fixed;
        }
        body {
            background: var(--primary-bg); font-family: var(--font-family); color: var(--text-color);
            display: flex; justify-content: center; align-items: center; text-align: center;
            overscroll-behavior: contain;
        }
        :root {
            --primary-bg: linear-gradient(135deg, #1e3c72, #2a5298);
            --container-bg: rgba(255, 255, 255, 0.15);
            --text-color: #ffffff; --text-muted: #cccccc;
            --accent-color: #66a6ff;
            --error-bg: rgba(220, 53, 69, 0.8); --success-bg: rgba(25, 135, 84, 0.8);
            --info-bg: rgba(13, 110, 253, 0.8); --button-hover-bg: rgba(255, 255, 255, 0.25);
            --border-color: rgba(255, 255, 255, 0.4); --shadow-color: rgba(0, 0, 0, 0.4);
            --button-disabled-opacity: 0.5; --border-radius: 10px;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --offline-color: #a0a0c0;
            /* Station Image Glow */
            --border-glow-blur: 12px;
            --border-glow-spread: 3px;
            --border-glow-opacity: 0.7;
            --border-glow-anim-duration: 3.5s;
            /* Select Styles */
            --select-bg: rgba(0, 0, 0, 0.2);
            --select-hover-bg: rgba(255, 255, 255, 0.1);
            --select-option-bg: #2a5298;
            --select-option-hover-bg: rgba(102, 166, 255, 0.3);
            /* Clock Styles */
            --clock-time-color: var(--text-color);
            --clock-date-color: var(--text-muted);
            --clock-greeting-color: var(--accent-color);
            /* Modal Logo Glow */
            --modal-glow-blur: 8px;
            --modal-glow-spread: 2px;
            --modal-glow-opacity: 0.6;
            --modal-glow-duration: 3.0s;
        }

        .container {
            position: relative; background: var(--container-bg); border-radius: var(--border-radius);
            padding: 20px; width: 95%; max-width: 400px; height: auto;
            max-height: 95vh; /* Limit height */
            overflow-y: auto; /* Allow scrolling if content exceeds height */
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 30px var(--shadow-color); border: 1px solid rgba(255, 255, 255, 0.2);
            overflow: visible; display: flex; flex-direction: column;
        }

        /* Station Display Area Wrapper */
        .station-display-area {
            display: flex;
            align-items: center; /* Vertically center items */
            justify-content: center; /* Center items horizontally */
            gap: 10px; /* Space between buttons and image */
            margin-bottom: 15px; /* Keep space below the area */
            position: relative; /* For potential absolute positioning inside if needed */
            min-height: 100px; /* Ensure it has height even if image is hidden initially */
            flex-shrink: 0; /* Prevent this area from shrinking */
        }

        /* Station Image */
        #stationImageContainer {
            width: 100px; /* Adjust size as needed */
            height: 100px; /* Keep it square */
            margin: 0; /* Remove auto margins as flex handles centering */
            border-radius: 8px; /* Slightly rounded corners */
            background: rgba(0, 0, 0, 0.25);
            overflow: hidden;
            display: none; /* Initially hidden, JS makes it visible */
            border: 1px solid var(--border-color);
            position: relative;
            box-shadow: none;
            transition: box-shadow 0.4s ease-out, opacity 0.3s ease-out; /* Added opacity transition */
            flex-shrink: 0; /* Prevent image container from shrinking */
        }
        #stationImageContainer.visible {
            display: block; /* This makes it appear */
        }
        #stationImage {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: cover; /* Fill the square container, may crop image edges */
            /* object-fit: contain; */ /* Uncomment this and comment above line if you want to see the whole image without cropping */
            border-radius: 6px; /* Slightly smaller radius than container */
            position: relative;
            z-index: 1;
            background-color: rgba(0,0,0,0.1); /* Placeholder background */
        }
         /* CSS Fallback for missing/broken main station image */
        #stationImage[src=""], #stationImage:error {
             content: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23cccccc"><path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4.86 8.86l-3 3.87L9 13.14 6 17h12l-3.86-5.14z"/></svg>');
             object-fit: contain; padding: 15px; /* Adjust padding for SVG */
        }
        /* Glow animation styles remain the same */
        @keyframes border-glow-rgb {
            0%   { box-shadow: 0 0 var(--border-glow-blur) var(--border-glow-spread) hsla(0,   100%, 65%, var(--border-glow-opacity)); }
            33%  { box-shadow: 0 0 var(--border-glow-blur) var(--border-glow-spread) hsla(120, 100%, 65%, var(--border-glow-opacity)); }
            66%  { box-shadow: 0 0 var(--border-glow-blur) var(--border-glow-spread) hsla(240, 100%, 65%, var(--border-glow-opacity)); }
            100% { box-shadow: 0 0 var(--border-glow-blur) var(--border-glow-spread) hsla(360, 100%, 65%, var(--border-glow-opacity)); }
        }
        #stationImageContainer.animating { animation: border-glow-rgb var(--border-glow-anim-duration) linear infinite; }

        /* Previous/Next Navigation Buttons */
        .nav-button {
            background: transparent;
            border: none;
            color: var(--text-color);
            padding: 8px !important; /* Use !important to override general button padding */
            margin: 0;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s ease, opacity 0.3s ease, transform 0.1s ease;
            line-height: 0; /* Prevent extra space */
            display: flex; /* Center icon */
            align-items: center;
            justify-content: center;
            box-shadow: none; /* Override default button shadow */
            flex-shrink: 0; /* Prevent buttons from shrinking */
        }
        .nav-button:hover:not(:disabled) {
            background: var(--button-hover-bg);
        }
        .nav-button:active:not(:disabled) {
            transform: scale(0.95);
        }
        .nav-button:disabled {
            opacity: var(--button-disabled-opacity);
            cursor: not-allowed;
            background: transparent;
        }
        .nav-button .material-symbols-outlined {
            font-size: 28px; /* Make icons slightly larger */
            vertical-align: middle;
        }


        /* Top Bar Layout */
        .top-bar {
            display: flex; align-items: center; gap: 10px; margin-bottom: 15px;
            position: relative; /* Needed for absolute positioning of buttons */
            min-height: 40px; justify-content: center;
            padding-left: 40px; /* Space for info button */
            padding-right: 40px; /* Space for update button */
             flex-shrink: 0;
        }
        #infoButton, #updateButton { /* Style both icon buttons */
            position: absolute; top: 50%; transform: translateY(-50%);
            background: transparent; padding: 5px; margin: 0; box-shadow: none;
            border: none; /* Ensure no default button border */
            color: var(--text-color); /* Ensure icon color matches */
            cursor: pointer; transition: background 0.2s ease, opacity 0.3s;
            border-radius: 50%; /* Make hover effect circular */
        }
        #infoButton { left: 0px; }
        #updateButton { right: 0px; }
        #infoButton:hover:not(:disabled), #updateButton:hover:not(:disabled) { background: var(--button-hover-bg); }
        #infoButton:disabled, #updateButton:disabled {
            opacity: var(--button-disabled-opacity);
            cursor: not-allowed;
            background: transparent; /* Ensure no background when disabled */
        }
        #infoButton .material-symbols-outlined,
        #updateButton .material-symbols-outlined { font-size: 24px; display: block; /* Fix potential layout shift */}
        .header { font-size: 24px; font-weight: 600; color: var(--text-color); margin: 0; flex-grow: 1; text-align: center; } /* Ensure header stays centered */

        /* Feedback */
        #feedbackMessage { padding: 10px 15px; margin-bottom: 10px; border-radius: 6px; font-size: 15px; font-weight: 500; color: var(--text-color); display: none; transition: opacity 0.5s ease-in-out, transform 0.3s ease; opacity: 0; transform: translateY(-10px); text-align: left;  flex-shrink: 0; }
        #feedbackMessage.show { display: block; opacity: 1; transform: translateY(0); }
        #feedbackMessage.error { background-color: var(--error-bg); }
        #feedbackMessage.success { background-color: var(--success-bg); }
        #feedbackMessage.info { background-color: var(--info-bg); }

        /* Buttons */
        button { font-family: var(--font-family); font-size: 16px; padding: 10px 18px; margin: 5px; border-radius: var(--border-radius); border: none; background: var(--button-hover-bg); color: var(--text-color); cursor: pointer; transition: background 0.3s, transform 0.15s, box-shadow 0.3s, opacity 0.3s; display: inline-flex; align-items: center; justify-content: center; gap: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); line-height: 1.2; }
        button:hover:not(:disabled) { background: rgba(255, 255, 255, 0.35); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
        button:active:not(:disabled) { transform: scale(0.96); box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        button:disabled { opacity: var(--button-disabled-opacity); cursor: not-allowed; background: rgba(255, 255, 255, 0.1); box-shadow: none; }
        .material-symbols-outlined { font-size: 20px; vertical-align: middle; }

        /* Dev Updates */
        .dev-label { font-size: 14px; font-weight: 500; color: var(--text-muted); margin-bottom: 5px; text-align: left;  flex-shrink: 0; }
        .dev-updates { background: rgba(0, 0, 0, 0.2); padding: 10px; border-radius: 6px; font-size: 14px; min-height: 35px; margin-bottom: 15px; color: var(--text-muted); text-align: left; line-height: 1.4; word-wrap: break-word;  flex-shrink: 0; }

        /* Custom Select Styles */
        .custom-select-container { position: relative; margin-bottom: 15px; width: 100%; font-family: var(--font-family); user-select: none;  flex-shrink: 0; }
        .custom-select-trigger { display: flex; align-items: center; padding: 10px 15px; border: 1px solid var(--border-color); border-radius: var(--border-radius); background-color: var(--select-bg); font-size: 16px; color: var(--text-color); cursor: pointer; transition: border-color 0.3s, box-shadow 0.3s; min-height: 48px; position: relative; }
        .custom-select-trigger:hover { border-color: var(--accent-color); }
        .custom-select-container.open .custom-select-trigger { border-bottom-left-radius: 0; border-bottom-right-radius: 0; border-color: var(--accent-color); box-shadow: 0 0 5px rgba(102, 166, 255, 0.5); }
        .custom-select-trigger .placeholder { color: var(--text-muted); flex-grow: 1; text-align: left; }
        .custom-select-trigger .selected-content { display: flex; align-items: center; gap: 10px; flex-grow: 1; text-align: left; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }
        .custom-select-trigger .station-logo-small { width: 24px; height: 24px; object-fit: cover; border-radius: 4px; flex-shrink: 0; background-color: rgba(255,255,255,0.1); vertical-align: middle; }
        .custom-select-trigger .arrow { font-family: 'Material Symbols Outlined'; font-variation-settings: 'FILL' 1; font-size: 24px; color: var(--text-muted); margin-left: auto; transition: transform 0.2s ease; }
        .custom-select-container.open .arrow { transform: rotate(180deg); }
        .custom-select-options { position: absolute; top: calc(100% - 1px); left: 0; right: 0; background-color: var(--select-option-bg); border: 1px solid var(--accent-color); border-top: none; border-radius: 0 0 var(--border-radius) var(--border-radius); list-style: none; padding: 0; margin: 0; max-height: 180px; overflow-y: auto; z-index: 10; opacity: 0; visibility: hidden; transform: translateY(-10px); transition: opacity 0.2s ease, visibility 0s linear 0.2s, transform 0.2s ease; box-shadow: 0 5px 10px rgba(0,0,0,0.3); }
        .custom-select-container.open .custom-select-options { opacity: 1; visibility: visible; transform: translateY(0); transition: opacity 0.2s ease, visibility 0s linear 0s, transform 0.2s ease; }
        .custom-select-option { display: flex; align-items: center; padding: 10px 15px; gap: 10px; cursor: pointer; transition: background-color 0.2s; color: var(--text-color); text-align: left; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        .custom-select-option:last-child { border-bottom: none; }
        .custom-select-option:hover:not(.offline-station) { background-color: var(--select-option-hover-bg); }
        .custom-select-option .station-logo-small { width: 32px; height: 32px; object-fit: cover; border-radius: 4px; flex-shrink: 0; background-color: rgba(255,255,255,0.1); vertical-align: middle; }
        .custom-select-option .station-name { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .custom-select-option.offline-station { color: var(--offline-color); font-style: italic; cursor: not-allowed; opacity: 0.7; }
        .custom-select-option.offline-station:hover { background-color: transparent; }
        .custom-select-option.offline-station .station-name::after { content: " (Offline)"; font-size: 0.9em; margin-left: 5px; }
        /* Fallback for missing/broken images in select */
        .custom-select-option img.station-logo-small[src=""],
        .custom-select-trigger img.station-logo-small[src=""],
        .custom-select-option img.station-logo-small:error,
        .custom-select-trigger img.station-logo-small:error {
             /* Instead of replacing content, hide broken img and show a placeholder span */
             display: none; /* Hide broken image icon */
        }
        .custom-select-option span.station-logo-small, /* Style for the fallback span */
        .custom-select-trigger span.station-logo-small {
             display: inline-block;
             width: 24px; height: 24px;
             background-color: rgba(255,255,255,0.1);
             border-radius: 4px;
             background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23cccccc"><path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4.86 8.86l-3 3.87L9 13.14 6 17h12l-3.86-5.14z"/></svg>');
             background-size: contain;
             background-repeat: no-repeat;
             background-position: center;
             vertical-align: middle;
        }
         .custom-select-option span.station-logo-small { /* Specific size for dropdown options */
             width: 32px; height: 32px;
         }

        /* Controls */
        .controls { display: flex; justify-content: center; align-items: center; margin-top: 10px; gap: 15px; flex-shrink: 0; }
        #playButton { min-width: 120px; }
        #volumeButton { background: transparent; border: none; outline: none; cursor: pointer; padding: 5px; margin: 0; box-shadow: none; transition: transform 0.2s, background 0.2s; border-radius: 50%; }
        #volumeButton:hover { transform: scale(1.1); background: var(--button-hover-bg); }
        #volumeButton svg { width: 26px; height: 26px; display: block; } /* Fix potential alignment issues */
        #volumeButton path { fill: var(--text-color); }
        #volumeButton line { stroke: var(--text-color); }

        /* Now Playing */
        #nowPlaying { font-size: 15px; padding: 8px; margin-top: 15px; color: var(--text-muted); min-height: 4em; line-height: 1.3; border-top: 1px solid var(--border-color); word-wrap: break-word; display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; flex-shrink: 0; }
        #nowPlayingText { margin-bottom: 5px; transition: color 0.3s; }
        .loading-dots { display: none; justify-content: center; align-items: center; height: 18px; /* Match playing animation height */ margin-top: 5px; }
        .loading-dots span { display: inline-block; width: 6px; height: 6px; background-color: var(--text-muted); border-radius: 50%; margin: 0 2px; animation: loading-bounce 1.4s infinite ease-in-out both; }
        .loading-dots span:nth-child(1) { animation-delay: -0.32s; }
        .loading-dots span:nth-child(2) { animation-delay: -0.16s; }
        @keyframes loading-bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }
        .playing-animation { display: none; height: 18px; align-items: flex-end; gap: 3px; margin-top: 5px; }
        .playing-animation.active { display: flex; }
        .playing-animation .bar { width: 3px; background-color: var(--accent-color); animation: playing-wave 1.2s infinite ease-in-out; border-radius: 1.5px; }
        .playing-animation .bar:nth-child(1) { height: 7px; animation-delay: -1.1s; }
        .playing-animation .bar:nth-child(2) { height: 13px; animation-delay: -1.0s; }
        .playing-animation .bar:nth-child(3) { height: 10px; animation-delay: -0.9s; }
        .playing-animation .bar:nth-child(4) { height: 16px; animation-delay: -0.8s; }
        .playing-animation .bar:nth-child(5) { height: 9px; animation-delay: -0.7s; }
        @keyframes playing-wave { 0%, 100% { transform: scaleY(0.3); } 50% { transform: scaleY(1.0); } }

        /* Date/Time Display */
        #dateTimeDisplay { margin-top: 15px; padding: 10px 0; text-align: center; border-top: 1px solid var(--border-color); flex-shrink: 0; }
        #currentGreeting { font-size: 1.1em; font-weight: 500; color: var(--clock-greeting-color); margin-bottom: 5px; }
        #currentTime { font-size: 1.4em; font-weight: 600; color: var(--clock-time-color); letter-spacing: 1px; margin-bottom: 5px; }
        #currentDate { font-size: 0.9em; color: var(--clock-date-color); }

        /* Modal Styles */
        #infoModal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background: rgba(0, 0, 0, 0.85); padding: 20px; backdrop-filter: blur(5px); }
        #modalContent { background: #fff; color: #333; margin: 15% auto; padding: 25px; border-radius: var(--border-radius); width: 90%; max-width: 400px; text-align: left; position: relative; box-shadow: 0 5px 15px rgba(0,0,0,0.3); max-height: 70vh; overflow-y: auto; }
        #modalClose { position: absolute; top: 10px; right: 10px; background: transparent; border: none; font-size: 28px; line-height: 1; cursor: pointer; color: #888; padding: 5px; }
        #modalClose:hover { color: #333; }
        .info-header {
            display: flex; align-items: center; gap: 12px; font-size: 20px; font-weight: 600; margin-bottom: 15px; color: #1e3c72; padding-bottom: 10px; border-bottom: 1px solid #eee;
        }
        .info-logo-container {
            width: 36px; height: 36px; border-radius: 50%; flex-shrink: 0; position: relative; animation: modal-logo-glow var(--modal-glow-duration) linear infinite; background: #eee; /* Fallback bg */
        }
        #infoModalLogo {
            display: block; width: 100%; height: 100%; object-fit: cover; border-radius: 50%; position: relative; z-index: 1; background-color: rgba(0,0,0,0.1); /* Placeholder bg */
        }
        /* CSS Fallback for missing/broken modal logo */
        #infoModalLogo[src=""], #infoModalLogo:error {
             content: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23cccccc"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>');
             object-fit: contain; padding: 5px; /* Add padding for SVG */
             background-color: #eee; /* Match container bg */
        }
        .info-content { font-size: 16px; color: #555; margin-bottom: 15px; line-height: 1.6; word-wrap: break-word; }
        .info-content strong { color: #333; }
        @keyframes modal-logo-glow {
            0%   { box-shadow: 0 0 var(--modal-glow-blur) var(--modal-glow-spread) hsla(0, 100%, 65%, var(--modal-glow-opacity)); }
            33%  { box-shadow: 0 0 var(--modal-glow-blur) var(--modal-glow-spread) hsla(120, 100%, 65%, var(--modal-glow-opacity));}
            66%  { box-shadow: 0 0 var(--modal-glow-blur) var(--modal-glow-spread) hsla(240, 100%, 65%, var(--modal-glow-opacity));}
            100% { box-shadow: 0 0 var(--modal-glow-blur) var(--modal-glow-spread) hsla(360, 100%, 65%, var(--modal-glow-opacity));}
        }

    </style>
</head>
<body>
    <div class="container">

        <!-- Station Display Area with Nav Buttons -->
        <div class="station-display-area">
            <button id="prevButton" class="nav-button" title="Previous Station" disabled>
                <span class="material-symbols-outlined">skip_previous</span>
            </button>
            <div id="stationImageContainer">
                <img id="stationImage" src="" alt="Station Logo" />
            </div>
            <button id="nextButton" class="nav-button" title="Next Station" disabled>
                <span class="material-symbols-outlined">skip_next</span>
            </button>
        </div>

        <!-- Header & Top Buttons -->
        <div class="top-bar">
            <button id="infoButton" title="Info"><span class="material-symbols-outlined">info</span></button>
            <div class="header">FM Radio</div>
            <button id="updateButton" title="Check for Updates"><span class="material-symbols-outlined">sync</span></button>
        </div>

        <!-- Feedback Message Area -->
        <div id="feedbackMessage"></div>

        <!-- Dev Updates Section -->
        <div class="dev-label">Dev Updates:</div>
        <div class="dev-updates" id="devUpdates">Loading...</div>

        <!-- Station Selection (Custom Dropdown) -->
        <div class="custom-select-container" id="customSelectContainer">
            <div class="custom-select-trigger" id="customSelectTrigger">
                <span class="placeholder">-- Select Station --</span>
                <span class="arrow">expand_more</span>
            </div>
            <ul class="custom-select-options" id="customSelectOptions"></ul>
        </div>

        <!-- Controls -->
        <div class="controls">
            <button id="playButton"><span class="material-symbols-outlined">play_arrow</span><span class="button-text">Play</span></button>
            <button id="volumeButton" title="Mute/Unmute">
                <svg id="volumeOnIcon" width="28" height="28" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm11 .88v4.24c1.28-.51 2.19-1.76 2.19-3.12s-.91-2.61-2.19-3.12zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
                <svg id="volumeOffIcon" width="28" height="28" viewBox="0 0 24 24" style="display: none;"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>
            </button>
        </div>

        <!-- Now Playing Display -->
        <div id="nowPlaying">
            <div id="nowPlayingText">Not Playing</div>
            <div class="loading-dots"><span></span><span></span><span></span></div>
             <div class="playing-animation">
                 <div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div>
             </div>
        </div>

        <!-- Date/Time Display Area -->
        <div id="dateTimeDisplay">
            <div id="currentGreeting"></div>
            <div id="currentTime">--:--:--</div>
            <div id="currentDate">---, --/--/----</div>
        </div>

    </div> <!-- End Container -->

    <!-- Modal for Info -->
    <div id="infoModal">
        <div id="modalContent">
            <button id="modalClose">&times;</button>
            <div class="info-header">
                <div class="info-logo-container">
                     <img id="infoModalLogo" src="" alt="Info Logo">
                 </div>
                <span>Info</span>
            </div>
            <div class="info-content" id="infoText">Loading info...</div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const playButton = document.getElementById('playButton');
        const playButtonIcon = playButton.querySelector('.material-symbols-outlined');
        const playButtonText = playButton.querySelector('.button-text');
        const nowPlaying = document.getElementById('nowPlaying');
        const nowPlayingText = document.getElementById('nowPlayingText');
        const loadingDots = nowPlaying.querySelector('.loading-dots');
        const playingAnimation = nowPlaying.querySelector('.playing-animation');
        const devUpdates = document.getElementById('devUpdates');
        const feedbackMessage = document.getElementById('feedbackMessage');
        const audio = new Audio();
        audio.preload = 'none'; // Important: prevent browser from preloading potentially large streams
        const stationImageContainer = document.getElementById('stationImageContainer');
        const stationImage = document.getElementById('stationImage');
        const infoButton = document.getElementById('infoButton');
        const updateButton = document.getElementById('updateButton');
        const infoModal = document.getElementById('infoModal');
        const modalClose = document.getElementById('modalClose');
        const infoText = document.getElementById('infoText');
        const volumeButton = document.getElementById('volumeButton');
        const volumeOnIcon = document.getElementById('volumeOnIcon');
        const volumeOffIcon = document.getElementById('volumeOffIcon');
        const customSelectContainer = document.getElementById('customSelectContainer');
        const customSelectTrigger = document.getElementById('customSelectTrigger');
        const customSelectOptions = document.getElementById('customSelectOptions');
        const triggerPlaceholder = customSelectTrigger.querySelector('.placeholder');
        const currentTimeDisplay = document.getElementById('currentTime');
        const currentDateDisplay = document.getElementById('currentDate');
        const currentGreetingDisplay = document.getElementById('currentGreeting');
        const infoModalLogo = document.getElementById('infoModalLogo');
        const prevButton = document.getElementById('prevButton'); // <-- Added
        const nextButton = document.getElementById('nextButton'); // <-- Added

        // --- Google Sheets API details ---
        const sheetId = '1eCXsyarPBetf6Z-0SawMnKbKicN3k4obahYtHOH_Q2I'; // Your Sheet ID
        const apiKey = 'AIzaSyCEzlwBxRNr6AmxC5vNW8jb_QHStNx2oWQ'; // Your API Key

        // --- Column Mapping (0-based index) ---
        // A: Stream Name (0)
        // B: Streaming URL (1)  <-- CHECK THESE URLs CAREFULLY
        // C: Channel Logo (for dropdown) (2)
        // D: Dev Updates (3)
        // E: Info Button Text (4)
        // F: Info Button Logo (5)
        // G: Main Display Image URL (6) <-- CHECK THESE URLs CAREFULLY
        // H: Offline Status (optional) (7)

        // --- Ranges based on structure ---
        const stationsRange = 'Sheet1!A:H';
        const stationsUrl = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${stationsRange}?key=${apiKey}`;
        const devUpdateRange = 'Sheet1!D2:D2';
        const devUpdateUrl = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${devUpdateRange}?key=${apiKey}`;
        const infoRange = 'Sheet1!E2:E2';
        const infoUrl = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${infoRange}?key=${apiKey}`;
        const infoLogoRange = 'Sheet1!F2:F2';
        const infoLogoUrl = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${infoLogoRange}?key=${apiKey}`;

        // --- State Variables ---
        let currentStations = [];
        let currentDevUpdate = "Loading...";
        let currentInfoText = "Loading info...";
        let currentInfoLogoUrl = null;
        let feedbackTimeout;
        let currentLoadTimeout;
        let currentStationName = "";
        let selectedStationValue = null;
        let updateIntervalId = null;
        const UPDATE_INTERVAL_MS = 30 * 60 * 1000; // 30 minutes
        let dateTimeIntervalId = null;
        // Named event listeners for easier removal
        let handleCanPlayListener = null;
        let handleErrorListener = null;
        let handleStalledListener = null;

        // --- Functions ---
        function showFeedback(message, type = 'info', duration = 4000) {
            if (feedbackTimeout) clearTimeout(feedbackTimeout);
            feedbackMessage.textContent = message;
            feedbackMessage.className = 'show'; // Reset classes first
            feedbackMessage.classList.add(type); // Then add the type class
            if (duration > 0) {
                feedbackTimeout = setTimeout(() => {
                    feedbackMessage.classList.remove('show');
                    setTimeout(() => { // Delay clearing text for fade effect
                        if (!feedbackMessage.classList.contains('show')) {
                            feedbackMessage.textContent = '';
                        }
                    }, 500);
                }, duration);
            } else {
                feedbackTimeout = null; // Persistent message
            }
        }
        function hideFeedback() {
             if (feedbackTimeout) clearTimeout(feedbackTimeout);
             feedbackMessage.classList.remove('show');
             setTimeout(() => { // Delay clearing text for fade effect
                 if (!feedbackMessage.classList.contains('show')) {
                     feedbackMessage.textContent = '';
                 }
             }, 500);
        }

        // --- UI Update Functions ---
        function showLoadingState(stationName) {
             nowPlayingText.textContent = `Loading ${stationName}...`;
             nowPlayingText.style.color = 'var(--text-muted)';
             loadingDots.style.display = 'flex';
             playingAnimation.classList.remove('active');
             playButtonIcon.textContent = "hourglass_empty";
             playButtonText.textContent = "Loading";
             playButton.disabled = true;
             stationImageContainer.classList.remove('animating');
             console.log(`UI State: Loading ${stationName}`);
        }
        function showPlayingState(stationName) {
             nowPlayingText.textContent = `Playing now: ${stationName}`;
             nowPlayingText.style.color = 'var(--accent-color)';
             loadingDots.style.display = 'none';
             playingAnimation.classList.add('active');
             playButtonIcon.textContent = "pause";
             playButtonText.textContent = "Pause";
             playButton.disabled = false;
             stationImageContainer.classList.add('visible');
             stationImageContainer.classList.add('animating');
             console.log(`UI State: Playing ${stationName}`);
        }
        function showPausedState() {
             const isPersistentStatus = ["Error", "Station Offline", "Update Failed", "Loading..."].includes(nowPlayingText.textContent);
             if (!isPersistentStatus && (playingAnimation.classList.contains('active') || loadingDots.style.display === 'flex')) {
                 nowPlayingText.textContent = "Paused";
                 nowPlayingText.style.color = 'var(--text-muted)';
                 loadingDots.style.display = 'none';
                 playingAnimation.classList.remove('active');
             } else if (!isPersistentStatus && nowPlayingText.textContent !== "Not Playing") {
                 // If paused without playing/loading before (e.g. initial state after load), ensure text is correct
                 nowPlayingText.textContent = "Not Playing";
                 nowPlayingText.style.color = 'var(--text-muted)';
             }
             if (!playButton.disabled) {
                 playButtonIcon.textContent = "play_arrow";
                 playButtonText.textContent = "Play";
             }
             const stationData = currentStations.find(s => s.url === selectedStationValue);
             if (stationData && !stationData.isOffline && (stationData.mainImageUrl || stationData.logoUrl)) {
                 stationImageContainer.classList.add('visible');
             } else {
                stationImageContainer.classList.remove('visible');
             }
             stationImageContainer.classList.remove('animating');
             console.log(`UI State: Paused`);
        }
        function showErrorState(message = "Error") {
             nowPlayingText.textContent = message;
             nowPlayingText.style.color = 'var(--error-bg)';
             loadingDots.style.display = 'none';
             playingAnimation.classList.remove('active');
             playButtonIcon.textContent = "play_arrow";
             playButtonText.textContent = "Play";
             playButton.disabled = false; // Allow retry
             stationImageContainer.classList.remove('visible', 'animating');
             console.log(`UI State: Error - ${message}`);
             updateNavButtonState(); // Update nav buttons in error state
        }
        function showIdleState(message = "Not Playing") {
             nowPlayingText.textContent = message;
             nowPlayingText.style.color = 'var(--text-muted)';
             loadingDots.style.display = 'none';
             playingAnimation.classList.remove('active');
             if (!playButton.disabled) {
                 playButtonIcon.textContent = "play_arrow";
                 playButtonText.textContent = "Play";
             }
             stationImageContainer.classList.remove('visible', 'animating');
             stationImage.src = ''; // Clear image when idle
             const persistentMessages = ["Station Offline", "Updating list...", "Checking for updates...", "Loading...", "Load Failed", "Error", "Update Failed"];
             if (!persistentMessages.includes(message)) {
                 updateCustomSelectTrigger(null);
                 if (selectedStationValue !== null) { // Only clear if a station WAS selected
                     selectedStationValue = null;
                     updateNavButtonState(); // Update nav buttons when selection is cleared
                 }
             }
              console.log(`UI State: Idle - ${message}`);
        }

        function updateStationImage(streamUrl) {
            const station = currentStations.find(s => s.url === streamUrl);
            console.log(`Updating station image for URL: ${streamUrl}`);

            if (!streamUrl || !station || station.isOffline) {
                console.log("  -> Hiding image: No valid URL, station, or offline.");
                stationImageContainer.classList.remove('visible', 'animating');
                stationImage.src = '';
                stationImage.alt = 'Station Logo';
                return;
            }
            const imageUrl = station.mainImageUrl || station.logoUrl;
            console.log(`  -> Found station: ${station.name}. Main Image: ${station.mainImageUrl}, Logo: ${station.logoUrl}`);
            console.log(`  -> Using image URL: ${imageUrl}`);

            if (imageUrl) {
                stationImage.src = imageUrl;
                stationImage.alt = `${station.name} Logo`;
                stationImageContainer.classList.add('visible');
                console.log(`  -> Set image src to ${imageUrl} and made container visible.`);

                if (!audio.paused && audio.readyState >= HTMLMediaElement.HAVE_FUTURE_DATA) {
                    stationImageContainer.classList.add('animating');
                    console.log("  -> Added playing animation to image.");
                } else {
                    stationImageContainer.classList.remove('animating');
                    console.log("  -> Removed playing animation from image (paused or not ready).");
                }
            } else {
                console.log("  -> Hiding image: No valid image URL found for this station.");
                stationImageContainer.classList.remove('visible', 'animating');
                stationImage.src = '';
                stationImage.alt = 'Station Logo';
            }
        }

        function updateCustomSelectTrigger(optionElement) {
             if (!optionElement) {
                 customSelectTrigger.innerHTML = `
                     <span class="placeholder">-- Select Station --</span>
                     <span class="arrow">expand_more</span>`;
             } else {
                 const name = optionElement.dataset.name;
                 const image = optionElement.dataset.image;
                 const isOffline = optionElement.classList.contains('offline-station');
                 let logoHtml = image
                     ? `<img src="${image}" alt="" class="station-logo-small" onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-block';"> <span class="station-logo-small" style="display: none;"></span>`
                     : `<span class="station-logo-small"></span>`;
                 customSelectTrigger.innerHTML = `
                     <span class="selected-content">
                         ${logoHtml}
                         <span>${name}${isOffline ? ' (Offline)' : ''}</span>
                     </span>
                     <span class="arrow">expand_more</span>`;
             }
        }

        // --- Data Fetching Functions ---
        function fetchStations(isUpdateCheck = false) {
            console.log("Fetching stations data...");
            let fetchedStations = [];
            if (!isUpdateCheck) {
                customSelectOptions.innerHTML = ''; currentStations = []; selectedStationValue = null; updateCustomSelectTrigger(null);
            }
            return fetch(stationsUrl)
                .then(response => { if (!response.ok) throw new Error(`HTTP ${response.status}`); return response.json(); })
                .then(data => {
                    if (data?.values && data.values.length > 1) {
                        data.values.slice(1).forEach((row, index) => {
                            if (row && row.length >= 2 && row[0]?.trim() && row[1]?.trim()) {
                                const stationName = String(row[0]).trim(); const stationUrl = String(row[1]).trim(); const logoUrl = (row.length > 2 && row[2]?.trim()) ? String(row[2]).trim() : null; const mainImageUrl = (row.length > 6 && row[6]?.trim()) ? String(row[6]).trim() : null; const isOffline = (row.length > 7 && row[7]?.trim()?.toLowerCase() === 'true');
                                fetchedStations.push({ name: stationName, url: stationUrl, logoUrl: logoUrl, mainImageUrl: mainImageUrl, isOffline: isOffline });
                                if (!isUpdateCheck) {
                                    const option = document.createElement('li'); option.classList.add('custom-select-option'); option.dataset.value = stationUrl; option.dataset.name = stationName; if (logoUrl) option.dataset.image = logoUrl;
                                    let logoHtml = logoUrl ? `<img src="${logoUrl}" alt="" class="station-logo-small" onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-block';"> <span class="station-logo-small" style="display: none;"></span>` : `<span class="station-logo-small"></span>`;
                                    option.innerHTML = `${logoHtml}<span class="station-name">${stationName}</span>`; if (isOffline) option.classList.add('offline-station'); customSelectOptions.appendChild(option);
                                }
                            } else { console.warn(`Skipping invalid station row ${index + 2}: Missing Name or URL. Row:`, row); }
                        });
                        console.log(`Loaded ${fetchedStations.length} valid stations.`);
                        if (fetchedStations.length === 0 && !isUpdateCheck) throw new Error("No valid station data found.");
                        if (!isUpdateCheck) currentStations = [...fetchedStations];
                    } else { if (!isUpdateCheck) throw new Error("No station data rows found."); else console.warn("No station data rows found during update check."); }
                    return fetchedStations;
                })
                .catch(error => { console.error("Error fetching/parsing stations:", error); if (!isUpdateCheck) { customSelectOptions.innerHTML = `<li class="custom-select-option" style="color: var(--error-bg); pointer-events: none;">Error loading stations</li>`; showFeedback(`Failed to load stations: ${error.message}`, "error", 0); } throw error; });
        }
        function fetchDevUpdate(isUpdateCheck = false) {
            console.log("Fetching dev update..."); let fetchedDevUpdate = "No update message available.";
            return fetch(devUpdateUrl)
                .then(response => { if (!response.ok) throw new Error(`HTTP ${response.status}`); return response.json(); })
                .then(data => { if (data?.values?.[0]?.[0] !== undefined && String(data.values[0][0]).trim()) { fetchedDevUpdate = String(data.values[0][0]).trim(); } else { console.warn("Dev update cell empty."); } if (!isUpdateCheck) { currentDevUpdate = fetchedDevUpdate; devUpdates.textContent = currentDevUpdate; } return fetchedDevUpdate; })
                .catch(error => { console.error("Error fetching Dev Update:", error); if (!isUpdateCheck) { currentDevUpdate = "Failed to load update."; devUpdates.textContent = currentDevUpdate; } return null; });
        }
        function fetchInfoText(isUpdateCheck = false) {
            console.log("Fetching info text..."); let fetchedInfoText = "No specific information found."; if (!isUpdateCheck && infoModal.style.display === "block") { infoText.innerHTML = "Loading details..."; }
            return fetch(infoUrl)
                .then(response => { if (!response.ok) throw new Error(`HTTP ${response.status}`); return response.json(); })
                .then(data => { if (data?.values?.[0]?.[0] !== undefined && String(data.values[0][0]).trim()) { fetchedInfoText = String(data.values[0][0]).trim(); } else { console.warn("Info text cell empty."); } if (!isUpdateCheck) { currentInfoText = fetchedInfoText; if (infoModal.style.display === "block") { infoText.innerHTML = currentInfoText.replace(/\n/g, '<br>'); } } return fetchedInfoText; })
                .catch(error => { console.error("Error fetching info text:", error); if (!isUpdateCheck) { currentInfoText = `Failed to load info: ${error.message}`; if (infoModal.style.display === "block") { infoText.innerHTML = currentInfoText; } } return null; });
        }
        function fetchInfoLogo(isUpdateCheck = false) {
            console.log("Fetching info logo..."); let fetchedLogoUrl = null;
            return fetch(infoLogoUrl)
                .then(response => { if (!response.ok) throw new Error(`HTTP ${response.status}`); return response.json(); })
                .then(data => { if (data?.values?.[0]?.[0] !== undefined && String(data.values[0][0]).trim()) { fetchedLogoUrl = String(data.values[0][0]).trim(); } else { console.warn("Info logo cell empty."); } if (!isUpdateCheck) { currentInfoLogoUrl = fetchedLogoUrl; if (infoModal.style.display === "block") { updateInfoModalLogo(); } } return fetchedLogoUrl; })
                .catch(error => { console.error("Error fetching Info Logo:", error); if (!isUpdateCheck) { currentInfoLogoUrl = null; if (infoModal.style.display === "block") { updateInfoModalLogo(); } } return null; });
        }
        function updateInfoModalLogo() {
            infoModalLogo.src = ''; infoModalLogo.onerror = null; infoModalLogo.onload = null;
            if (currentInfoLogoUrl) { infoModalLogo.src = currentInfoLogoUrl; infoModalLogo.onerror = () => { console.warn("Failed to load info modal logo:", currentInfoLogoUrl); infoModalLogo.onerror = null; }; infoModalLogo.onload = () => { infoModalLogo.onerror = null; }; }
            else { infoModalLogo.src = ""; }
        }

        // --- Audio Playback ---
        function handleAudioPlaySuccess(stationName) {
             console.log(`Playback started successfully for ${stationName}`);
             showPlayingState(stationName);
             updateMediaSession(stationName, "Playing");
             updateNavButtonState(); // Update nav buttons when play succeeds
        }
        function handleAudioError(error, stationName = "Station") {
            console.error(`AUDIO PLAYBACK ERROR for ${stationName}:`, error); if (audio.error) { console.error("Audio Element Error Details:", audio.error); } let message = `Error playing ${stationName}.`;
            if (error?.message?.includes("Timeout")) { message = `Timeout loading ${stationName}. Check connection or stream URL.`; }
            else if (audio.error) { switch (audio.error.code) { case 1: message = `${stationName}: Playback stopped.`; break; case 2: message = `${stationName}: Network error. Check connection/stream.`; break; case 3: message = `${stationName}: Audio decoding error. Stream might be invalid.`; break; case 4: message = `${stationName}: Format not supported or URL blocked (CORS?).`; break; default: message = `Playback error for ${stationName}. (Code: ${audio.error.code})`; } if (audio.error.code === 2 || audio.error.code === 4) { message += " Verify URL and check console (F12) for CORS errors."; } }
            else if (error?.name === 'NotAllowedError') { message = `Browser blocked autoplay for ${stationName}. Click play manually.`; }
            else { message = `Unknown playback error for ${stationName}.`; if(error?.message) message += ` (${error.message})`; }
            showFeedback(message, "error", 10000); showErrorState("Error"); updateMediaSession(currentStationName || "Radio", "Error");
            audio.pause(); if (audio.src) { audio.removeAttribute('src'); audio.load(); console.log("Audio src removed and load() called after error."); }
            if (currentLoadTimeout) clearTimeout(currentLoadTimeout); removeAudioAttemptListeners();
        }
        function removeAudioAttemptListeners() {
             if (handleCanPlayListener) audio.removeEventListener('canplay', handleCanPlayListener); if (handleErrorListener) audio.removeEventListener('error', handleErrorListener); if (handleStalledListener) audio.removeEventListener('stalled', handleStalledListener);
             handleCanPlayListener = null; handleErrorListener = null; handleStalledListener = null; console.log("Removed specific audio attempt event listeners.");
        }
        function playStation() {
            const streamUrl = selectedStationValue; if (!streamUrl) { showFeedback("Please select a station first.", "info"); return; }
            const stationData = currentStations.find(s => s.url === streamUrl); if (!stationData) { console.error("Selected station data not found:", streamUrl); showFeedback("Error: Station data missing.", "error"); showErrorState("Error"); return; }
            if (stationData.isOffline) { console.log(`Selected station is offline: ${stationData.name}`); showFeedback(`${stationData.name} is currently offline.`, "info", 5000); showIdleState("Station Offline"); audio.pause(); if (audio.src) { audio.removeAttribute('src'); audio.load(); } if (currentLoadTimeout) clearTimeout(currentLoadTimeout); removeAudioAttemptListeners(); updateMediaSession("FM Radio", "Idle"); updateStationImage(null); updateNavButtonState(); return; }
            currentStationName = stationData.name; updateStationImage(streamUrl); console.log(`Attempting to play: ${currentStationName} (${streamUrl})`); hideFeedback(); audio.pause();
            if (currentLoadTimeout) clearTimeout(currentLoadTimeout); removeAudioAttemptListeners();
            console.log("Setting new audio src and preparing to load."); try { audio.src = streamUrl; } catch (e) { console.error("Error setting audio src:", e); handleAudioError(e, currentStationName); return; }
            showLoadingState(currentStationName); updateMediaSession(currentStationName, "Loading...");
            handleCanPlayListener = () => { console.log(`'canplay' event received for ${currentStationName}. ReadyState: ${audio.readyState}`); clearTimeout(currentLoadTimeout); audio.removeEventListener('stalled', handleStalledListener); if (!audio.error) { audio.play().then(() => { handleAudioPlaySuccess(currentStationName); if (handleErrorListener) audio.removeEventListener('error', handleErrorListener); handleErrorListener = null; }).catch((err) => { console.error("Audio play() promise rejected:", err); handleAudioError(err, currentStationName); removeAudioAttemptListeners(); }); } else { console.warn("'canplay' fired but audio.error is already set. Aborting play attempt."); removeAudioAttemptListeners(); } };
            handleErrorListener = (event) => { console.error(`'error' event received for ${currentStationName}. Event:`, event); clearTimeout(currentLoadTimeout); removeAudioAttemptListeners(); handleAudioError(audio.error || new Error('Audio element error event'), currentStationName); };
            handleStalledListener = () => { console.warn(`'stalled' event received for ${currentStationName}. Network might be slow or interrupted.`); };
            audio.addEventListener('canplay', handleCanPlayListener, { once: true }); audio.addEventListener('error', handleErrorListener, { once: true }); audio.addEventListener('stalled', handleStalledListener, { once: true });
            console.log("Calling audio.load()..."); audio.load();
            currentLoadTimeout = setTimeout(() => { console.warn(`Load timeout reached for ${currentStationName}. 'canplay' event did not fire.`); removeAudioAttemptListeners(); handleAudioError(new Error("Timeout: Station took too long to load."), currentStationName); }, 25000);
        }

        // --- Media Session API ---
        function updateMediaSession(title = "FM Radio", status = "Idle") {
            if ('mediaSession' in navigator) { try { const safeTitle = title.replace(" (Offline)", "").trim(); const currentStationData = currentStations.find(s => s.name === safeTitle); const artworkUrl = (currentStationData && !currentStationData.isOffline) ? (currentStationData.mainImageUrl || currentStationData.logoUrl) : null; const metadata = { title: safeTitle, artist: "Live Stream", album: `Status: ${status}` }; if (artworkUrl) { metadata.artwork = [ { src: artworkUrl, sizes: '512x512', type: 'image/png' } ]; } else { metadata.artwork = []; } navigator.mediaSession.metadata = new MediaMetadata(metadata); navigator.mediaSession.playbackState = audio.paused ? "paused" : "playing"; } catch (error) { console.warn("Error updating Media Session:", error); } }
        }
        function setupMediaSessionActions() {
            if ('mediaSession' in navigator) { try { navigator.mediaSession.setActionHandler('play', () => { console.log('Media Session: Play action.'); if (audio.paused) { if (selectedStationValue) { const stationData = currentStations.find(s => s.url === selectedStationValue); if (stationData && stationData.isOffline) { showFeedback(`${stationData.name} is offline.`, "info"); showIdleState("Station Offline"); return; } if (audio.src === selectedStationValue && !audio.error && audio.readyState >= HTMLMediaElement.HAVE_FUTURE_DATA) { audio.play().then(() => handleAudioPlaySuccess(currentStationName)).catch((err) => playStation()); } else { playStation(); } } else { showFeedback("Select a station first.", "info"); } } }); navigator.mediaSession.setActionHandler('pause', () => { console.log('Media Session: Pause action.'); if (!audio.paused) { audio.pause(); } }); navigator.mediaSession.setActionHandler('stop', () => { console.log('Media Session: Stop action.'); if (!audio.paused) { audio.pause(); } }); } catch (error) { console.error('Error setting up Media Session action handlers:', error); } }
        }

        // --- Other Functions ---
        function toggleMute() { audio.muted = !audio.muted; updateVolumeIcon(); }
        function updateVolumeIcon() { volumeOnIcon.style.display = audio.muted ? 'none' : 'block'; volumeOffIcon.style.display = audio.muted ? 'block' : 'none'; }
        function lockOrientation() { try { if (screen.orientation?.lock) { screen.orientation.lock('portrait-primary').catch(e => console.warn('Orientation lock failed:', e.message)); } } catch (e) { console.warn('Orientation lock error:', e.message); } }

        // --- Navigation Button Logic ---
        function findCurrentOnlineStationIndex() {
            if (!selectedStationValue || !currentStations || currentStations.length === 0) { return -1; }
            const onlineStations = currentStations.filter(s => !s.isOffline);
            return onlineStations.findIndex(s => s.url === selectedStationValue);
        }
        function updateNavButtonState() {
            const onlineStations = currentStations.filter(s => !s.isOffline);
            const stationCount = onlineStations.length;
            const currentIndex = findCurrentOnlineStationIndex();
            // console.log(`Updating Nav: Count=${stationCount}, CurrentIndex=${currentIndex}`);
            if (currentIndex === -1 || stationCount <= 1) {
                prevButton.disabled = true; nextButton.disabled = true;
            } else {
                prevButton.disabled = (currentIndex === 0);
                nextButton.disabled = (currentIndex === stationCount - 1);
            }
        }
        function nextStation() {
            console.log("Next button clicked"); const onlineStations = currentStations.filter(s => !s.isOffline); if (onlineStations.length <= 1) return;
            const currentIndex = findCurrentOnlineStationIndex();
            let nextIndex;
            if (currentIndex === -1) { // If nothing selected, play first
                nextIndex = 0;
            } else {
                 nextIndex = currentIndex + 1;
            }
            if (nextIndex < onlineStations.length) {
                const nextStationData = onlineStations[nextIndex];
                const optionElement = customSelectOptions.querySelector(`.custom-select-option[data-value="${CSS.escape(nextStationData.url)}"]`);
                if (optionElement && !optionElement.classList.contains('offline-station')) {
                    selectedStationValue = nextStationData.url; updateCustomSelectTrigger(optionElement); playStation(); updateNavButtonState();
                } else { console.error("Could not find next online option element for:", nextStationData?.name); }
            } else { console.log("Already at the last online station."); }
        }
        function previousStation() {
            console.log("Previous button clicked"); const onlineStations = currentStations.filter(s => !s.isOffline); if (onlineStations.length <= 1) return;
            const currentIndex = findCurrentOnlineStationIndex();
            let prevIndex;
            if (currentIndex === -1) { // If nothing selected, play last
                 prevIndex = onlineStations.length - 1;
            } else {
                prevIndex = currentIndex - 1;
            }
            if (prevIndex >= 0) {
                const prevStationData = onlineStations[prevIndex];
                const optionElement = customSelectOptions.querySelector(`.custom-select-option[data-value="${CSS.escape(prevStationData.url)}"]`);
                if (optionElement && !optionElement.classList.contains('offline-station')) {
                    selectedStationValue = prevStationData.url; updateCustomSelectTrigger(optionElement); playStation(); updateNavButtonState();
                } else { console.error("Could not find previous online option element for:", prevStationData?.name); }
            } else { console.log("Already at the first online station."); }
        }

        // --- Automatic & Manual Update Check ---
        async function runUpdateCheck(isManualCheck = false) {
            const checkType = isManualCheck ? "Manual" : "Periodic";
            console.log(`${checkType} update check running. Audio paused: ${audio.paused}`);
            if (!isManualCheck && !audio.paused) { console.log("Skipping periodic update check: Audio is playing."); return; }
            let wasPlayingBeforeManualCheck = false;
            if (isManualCheck && !audio.paused) { console.log("Pausing audio for manual update check."); audio.pause(); wasPlayingBeforeManualCheck = true; await new Promise(resolve => setTimeout(resolve, 100)); }
            if (isManualCheck && updateButton) { updateButton.disabled = true; }
            if (isManualCheck) { showIdleState("Checking for updates..."); }
            let newData = {}; let criticalFetchError = false; let updateSucceeded = false;
            try {
                const results = await Promise.allSettled([ fetchStations(true), fetchDevUpdate(true), fetchInfoText(true), fetchInfoLogo(true) ]);
                if (results[0].status === 'fulfilled') { newData.stations = results[0].value; } else { console.error(`${checkType} update failed for Stations:`, results[0].reason); criticalFetchError = true; }
                if (results[1].status === 'fulfilled') newData.devUpdate = results[1].value; else console.warn(`${checkType} update check failed for Dev Update:`, results[1].reason);
                if (results[2].status === 'fulfilled') newData.infoText = results[2].value; else console.warn(`${checkType} update check failed for Info Text:`, results[2].reason);
                if (results[3].status === 'fulfilled') newData.infoLogo = results[3].value; else console.warn(`${checkType} update check failed for Info Logo:`, results[3].reason);
                if (criticalFetchError) { console.log(`Aborting ${checkType} update comparison due to critical fetch error (Stations).`); if (isManualCheck) { showFeedback("Update check failed: Could not load station data.", "error", 5000); showIdleState("Update Failed"); } return; }
                let stationsChanged = (newData.stations && JSON.stringify(newData.stations) !== JSON.stringify(currentStations));
                let devUpdateChanged = (newData.devUpdate !== undefined && newData.devUpdate !== currentDevUpdate);
                let infoTextChanged = (newData.infoText !== undefined && newData.infoText !== currentInfoText);
                let infoLogoChanged = (newData.infoLogo !== undefined && newData.infoLogo !== currentInfoLogoUrl);
                if (stationsChanged || devUpdateChanged || infoTextChanged || infoLogoChanged) {
                    console.log(`${checkType}: Data changed, updating state and potentially UI...`); updateSucceeded = true;
                    const oldSelectedValue = selectedStationValue; // Store old selection
                    if (stationsChanged) {
                         currentStations = [...newData.stations];
                         // Rebuild dropdown
                         customSelectOptions.innerHTML = '';
                         currentStations.forEach(station => {
                            const option = document.createElement('li'); option.classList.add('custom-select-option'); option.dataset.value = station.url; option.dataset.name = station.name; if (station.logoUrl) option.dataset.image = station.logoUrl;
                            let logoHtml = station.logoUrl ? `<img src="${station.logoUrl}" alt="" class="station-logo-small" onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-block';"> <span class="station-logo-small" style="display: none;"></span>` : `<span class="station-logo-small"></span>`;
                            option.innerHTML = `${logoHtml}<span class="station-name">${station.name}</span>`; if (station.isOffline) option.classList.add('offline-station'); customSelectOptions.appendChild(option);
                         });
                         // Try to re-select the previously selected station if it still exists and is online
                         const reselectStation = currentStations.find(s => s.url === oldSelectedValue && !s.isOffline);
                         if(reselectStation) {
                             selectedStationValue = reselectStation.url;
                             const reselectOption = customSelectOptions.querySelector(`.custom-select-option[data-value="${CSS.escape(reselectStation.url)}"]`);
                             if(reselectOption) updateCustomSelectTrigger(reselectOption);
                             else selectedStationValue = null; // Fallback if option not found
                         } else {
                             selectedStationValue = null; // Clear selection if old one is gone/offline
                         }
                         if(!selectedStationValue) updateCustomSelectTrigger(null); // Update trigger if selection cleared
                    }
                    if (devUpdateChanged) currentDevUpdate = newData.devUpdate;
                    if (infoTextChanged) currentInfoText = newData.infoText;
                    if (infoLogoChanged) currentInfoLogoUrl = newData.infoLogo;
                    let uiUpdated = false;
                    if (stationsChanged) { console.log("Rebuilding station dropdown UI..."); uiUpdated = true; updateNavButtonState(); } // Update nav buttons after list rebuild
                    if (devUpdateChanged) { console.log("Updating Dev Updates UI..."); devUpdates.textContent = currentDevUpdate || "(No update message)"; uiUpdated = true; }
                    if (isManualCheck) { showFeedback("App data updated.", "success", 3000); showIdleState("Not Playing"); } // Set idle after manual update
                    else if (uiUpdated) { console.log("Automatic update applied changes."); showIdleState("Not Playing"); } // Set idle after auto update only if UI changed
                } else {
                    console.log(`${checkType}: No data changes detected.`); updateSucceeded = true;
                    if (isManualCheck) { showFeedback("App is up to date.", "success", 3000); showIdleState("Not Playing"); }
                }
            } catch (error) { console.error(`Error during ${checkType} update check process:`, error); if (isManualCheck) { showFeedback("Update check failed. Please try again later.", "error", 5000); showIdleState("Update Failed"); }
            } finally {
                 if (isManualCheck && updateButton) { updateButton.disabled = false; console.log("Manual update check complete, button re-enabled."); }
                 if (isManualCheck && wasPlayingBeforeManualCheck && updateSucceeded && selectedStationValue) {
                    console.log("Attempting to resume playback after manual update.");
                    const stationData = currentStations.find(s => s.url === selectedStationValue);
                    if (stationData && !stationData.isOffline) { playStation(); }
                    else { console.log("Previous station now offline/invalid. Staying paused."); showFeedback("Previous station unavailable after update.", "info", 4000); showIdleState(stationData?.isOffline ? "Station Offline" : "Not Playing"); selectedStationValue = null; updateCustomSelectTrigger(null); updateNavButtonState(); }
                 } else if(isManualCheck && !wasPlayingBeforeManualCheck) { showIdleState("Not Playing"); } // Ensure idle if wasn't playing
                 else if (isManualCheck) { updateNavButtonState(); } // Ensure nav buttons are correct after manual check finishes
            }
        }

        // --- Date/Time Update Function ---
        function updateDateTime() {
            const now = new Date(); const timeZone = 'Asia/Kolkata';
            try { const timeString = now.toLocaleString('en-US', { timeZone: timeZone, hour: 'numeric', minute: '2-digit', second: '2-digit', hour12: true }); currentTimeDisplay.textContent = timeString; const dateString = now.toLocaleString('en-GB', { timeZone: timeZone, weekday: 'long', day: '2-digit', month: '2-digit', year: 'numeric' }); currentDateDisplay.textContent = dateString; const hourIST = parseInt(now.toLocaleString('en-US', { timeZone: timeZone, hour: 'numeric', hour12: false }), 10); let greeting = ""; if (hourIST >= 5 && hourIST < 12) { greeting = "Good Morning"; } else if (hourIST >= 12 && hourIST < 17) { greeting = "Good Afternoon"; } else if (hourIST >= 17 && hourIST < 21) { greeting = "Good Evening"; } else { greeting = "Good Night"; } currentGreetingDisplay.textContent = greeting; } catch (e) { console.error("Error formatting date/time:", e); const fallbackTime = now.toLocaleTimeString(); const fallbackDate = now.toLocaleDateString(); currentTimeDisplay.textContent = fallbackTime; currentDateDisplay.textContent = fallbackDate; currentGreetingDisplay.textContent = "Hello"; }
        }

        // --- Event Listeners ---
        customSelectTrigger.addEventListener('click', (e) => { e.stopPropagation(); customSelectContainer.classList.toggle('open'); });
        customSelectOptions.addEventListener('click', (e) => {
            const option = e.target.closest('.custom-select-option'); if (!option) return;
            if (option.classList.contains('offline-station')) { showFeedback(`${option.dataset.name} is currently offline.`, "info", 4000); return; }
            selectedStationValue = option.dataset.value; updateCustomSelectTrigger(option); customSelectContainer.classList.remove('open');
            console.log("Station selected via dropdown, calling playStation()."); playStation(); updateNavButtonState();
        });
        document.addEventListener('click', (e) => { if (!customSelectContainer.contains(e.target) && customSelectContainer.classList.contains('open')) { customSelectContainer.classList.remove('open'); } });
        playButton.addEventListener('click', () => {
            if (!selectedStationValue) { showFeedback("Please select a station first.", "info"); return; }
            const stationData = currentStations.find(s => s.url === selectedStationValue); if (stationData && stationData.isOffline) { showFeedback(`${stationData.name} is currently offline.`, "info", 5000); showIdleState("Station Offline"); return; }
            if (audio.paused) { console.log("Play button clicked while paused."); if (audio.src === selectedStationValue && !audio.error && audio.readyState >= HTMLMediaElement.HAVE_FUTURE_DATA) { console.log("Attempting to resume playback."); audio.play().then(() => handleAudioPlaySuccess(currentStationName)).catch((err) => { console.warn("Resume failed, trying full playStation().", err); playStation(); }); } else { console.log("Conditions not met for resume, starting fresh with playStation()."); playStation(); } }
            else { console.log("Pause button clicked while playing."); audio.pause(); }
        });
        infoButton.addEventListener('click', () => { infoText.innerHTML = currentInfoText ? currentInfoText.replace(/\n/g, '<br>') : "Information not available."; updateInfoModalLogo(); infoModal.style.display = "block"; });
        updateButton.addEventListener('click', () => { runUpdateCheck(true); });
        modalClose.addEventListener('click', () => { infoModal.style.display = "none"; });
        window.addEventListener('click', (event) => { if (event.target == infoModal) { infoModal.style.display = "none"; } });
        volumeButton.addEventListener('click', toggleMute);
        prevButton.addEventListener('click', previousStation);
        nextButton.addEventListener('click', nextStation);

        // --- Audio Element Event Listeners (Global) ---
        audio.addEventListener('pause', () => { console.log("Global audio 'pause' event triggered."); const isErrorOrLoading = (nowPlayingText.textContent === 'Error' || loadingDots.style.display === 'flex' || nowPlayingText.textContent.startsWith("Loading") || nowPlayingText.textContent === "Buffering..."); if (!isErrorOrLoading) { showPausedState(); } else { console.log("Pause event UI update skipped due to error/loading/buffering state."); stationImageContainer.classList.remove('animating'); playingAnimation.classList.remove('active'); } updateMediaSession(currentStationName || "Radio", "Paused"); updateNavButtonState(); });
        audio.addEventListener('ended', () => { console.log("Global audio 'ended' event triggered."); showIdleState(); showFeedback("Stream has ended.", "info"); updateMediaSession(currentStationName || "Radio", "Ended"); updateNavButtonState(); });
        audio.addEventListener('play', () => { console.log("Global audio 'play' event triggered (indicates play() was called or resumed)."); updateMediaSession(currentStationName || "Radio", "Playing"); }); // Don't update nav buttons here, wait for 'playing'
        audio.addEventListener('playing', () => { console.log("Global audio 'playing' event triggered (actual playback started/resumed)."); if (!playingAnimation.classList.contains('active')) { showPlayingState(currentStationName || "Selected Station"); } updateMediaSession(currentStationName || "Radio", "Playing"); updateNavButtonState(); }); // Update nav buttons when actually playing
        audio.addEventListener('loadstart', () => { console.log("Global audio 'loadstart' event triggered."); if (audio.paused || !audio.src) { stationImageContainer.classList.remove('animating'); } });
        audio.addEventListener('waiting', () => { console.log("Global audio 'waiting' event triggered (buffering)."); nowPlayingText.textContent = "Buffering..."; nowPlayingText.style.color = 'var(--text-muted)'; loadingDots.style.display = 'flex'; playingAnimation.classList.remove('active'); stationImageContainer.classList.remove('animating'); if (!playButton.disabled) { playButtonIcon.textContent = "hourglass_empty"; playButtonText.textContent = "Buffering"; playButton.disabled = true; } updateMediaSession(currentStationName || "Radio", "Buffering..."); updateNavButtonState(); }); // Update nav buttons during buffering
        audio.addEventListener('canplay', () => { console.log("Global audio 'canplay' event triggered (ready to play)."); if (loadingDots.style.display === 'flex') { loadingDots.style.display = 'none'; } if (playButton.disabled && (playButtonText.textContent === "Buffering" || playButtonText.textContent === "Loading")) { playButton.disabled = false; const isActuallyPlaying = !audio.paused && audio.currentTime > 0 && audio.readyState >= HTMLMediaElement.HAVE_FUTURE_DATA; playButtonIcon.textContent = isActuallyPlaying ? "pause" : "play_arrow"; playButtonText.textContent = isActuallyPlaying ? "Pause" : "Play"; if (!isActuallyPlaying && (nowPlayingText.textContent === "Buffering..." || nowPlayingText.textContent.startsWith("Loading"))) { showPausedState(); } updateNavButtonState(); } else if (!playButton.disabled){ updateNavButtonState(); } /* Update nav buttons when ready */ });

        // --- Initial Setup ---
        function initialLoad() {
            console.log("Starting initial data load..."); showFeedback("Loading initial data...", "info", 0); showIdleState("Loading...");
            updateDateTime(); if (dateTimeIntervalId) clearInterval(dateTimeIntervalId); dateTimeIntervalId = setInterval(updateDateTime, 1000);
            Promise.allSettled([ fetchStations(), fetchDevUpdate(), fetchInfoText(), fetchInfoLogo() ])
                .then(results => {
                    hideFeedback(); let stationsLoaded = false;
                    if (results[0].status === 'fulfilled' && results[0].value && results[0].value.length > 0) { stationsLoaded = true; console.log("Initial Stations loaded successfully."); }
                    else { const reason = results[0].reason || "No stations found"; console.error(`Initial Stations fetch failed or empty:`, reason); if (!feedbackMessage.classList.contains('show')) { showFeedback(results[0].reason?.message || "No stations found.", "error", 0); } }
                    if (results[1].status === 'rejected') console.error(`Initial Dev Update fetch failed:`, results[1].reason); if (results[2].status === 'rejected') console.error(`Initial Info Text fetch failed:`, results[2].reason); if (results[3].status === 'rejected') console.error(`Initial Info Logo fetch failed:`, results[3].reason);
                    if (stationsLoaded) { console.log("Initial setup complete. Ready."); showIdleState(); } else { console.warn("Initial setup failed (Stations)."); showIdleState("Load Failed"); }
                    updateNavButtonState(); // Update nav buttons after initial load attempt
                    if (updateIntervalId) clearInterval(updateIntervalId); updateIntervalId = setInterval(() => runUpdateCheck(false), UPDATE_INTERVAL_MS); console.log(`Automatic update check scheduled every ${UPDATE_INTERVAL_MS / 1000 / 60} minutes.`);
                }).catch(err => { console.error("Unexpected error during initial load sequence:", err); hideFeedback(); showIdleState("Fatal Error"); showFeedback("A critical error occurred during startup.", "error", 0); updateNavButtonState(); }); // Also update nav buttons on fatal error
            updateVolumeIcon(); setupMediaSessionActions(); updateMediaSession(); lockOrientation(); updateNavButtonState(); // Initial state update for nav buttons
        }

        // --- Start App ---
        document.addEventListener('DOMContentLoaded', initialLoad);
    </script>
</body>
</html>